
server: mysql 그 자체 (커맨드 라인으로 일일히 명령어를 쳐야함)

workbench: sql 화면 보여주면서 작업 가능하게함

example ~~: 우리 실습할 샘플데이터 제공해준다.

documentation: 영어로된 메뉴얼이다. 버거형 아니면 쓸일 없다. 보통은 document 건너뛰고 설치할 때가 많다.

===============
- SQL 을 왜 하는가?
100만줄 이상의 데이터, 이처럼 대량의 데이터를 처리해야 할 때 필요하다. 
엑셀의 한계치 100만줄.

ex> 동물 iot 데이터 기반 건강진단 스타트업 데이터분석가

실시간 블루투스 전송으로 활동량 데이터 전송
1분마다 데이터 전송 -> 1 * 60 * 24 *n(동물 개체수)
이게 지속된다면 ?
===============

===============
갤럭시워치로 인간의 활동량, 건강데이터 수집

삼성 의료원과 삼성생명에 보내서 생명은 사람 건강생태로 보험시장 판단
의료원은 건강검진 시장을 노림.
-> 빅데이터는 비즈니스 가능성을 가진다.
===============

SQL 같은 프로그램을 DBMS(database management system) 이라고부른다.

DBMS 중에 테이블간 연계가 가능한 것을 관계형 DBMS 라고 한다.
MYSQL 은 관계형 DBMS (RELATIONAL DBMS)


==================
SQL

테이블을 나누는 이유

테이블내 일부 정보만 필요한 데이터가 빈공간을 차지하는데(0값 들어갈 친구)
1. 데이터의 0 값은 하드디스크 공간 낭비
2. 느려진다.

SQL 데이터 설계의 목표는 가능하면  빈공간 차지하는 잉여데이터값의 최소화

회원 테이블, 지원테이블, 구매테이블, 물품테이블 같이 테이블 정보를 나눠서 
필요한 내용을 필요한 만큼의 공간에 집어넣는게 핵심이다.
====================


※ SQL Workbench 실행하면 된다.

CREATE_SCHEMA
SCHEMA : 데이터테이블의 집합이다.

스키마 생성시 보이는 코드
CREATE SCHEMA `shop_db` DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci ;
 								
다국적 언어를 지원하는 shop_db 라는 이름의 데이터 베이스를 만든다. 라는 의미


workbench 프로그램의 특징 : CLI (COMMAND LINE TINTERFACE) 가 불편하니 
GUI로 쓰려고 (GRAPHIC USER INTERFACE)
===========================

테이블 생성

table name 에 member_id , 그리고 datatype 을 char(8)
char(8) - 8글자로 이루어진 문자데이터

PK NN UQ AI UN 등 - 이것들은 데이터의 속성을 나타낸다.

PK - primary key
= 데이터 관계를 설명하는 값으로 그 데이터가 메인으로 가지는 구분자. 
   각 테이블에서 primary key 는 하나만 사용할 수 있다.
   중복 및 빈 데이터를 허용하지 않는다.

ex) 쿠팡 고객정보 테이블을 상상해보자. 고객별 id가 primary key 의 예시
= 고객별 id는 중복을 허용하지 않는다. 즉 고유값 존재, 빈칸 허용X
   기업에서는 사번, 나라에서는 주민번호, 쿠팡에서는 로그인 아이디 등 
   이런 것들이 primary key 의 예시이다.

NN - not null (빈값을 허용하지 않음)
= pk 속성을 가지면 거의 자동으로 nn 속성을 가진다.
   
UQ - unique ( 고유값을 가진다.)

AI - auto increment (데이터 자동증가)
= 유저가 따로 입력 안해도 해당 행에 데이터가 있다면 자동으로 값을 채워준다.
   좋은 예시는 금일 방문 손님 수 - 자동으로 데이터가 들어오면 번호를 하나씩 증가시키며 번호를 매긴다.


member_id : pk, nn id니까 고유값으로 설정
member_name : nn
member_addr: 주소값, 주소는 입력안해도 허용


# shop_db 내부에 member 라는 테이블 만들어서
# 3개의 컬럼 생성후
# primary key는 member_id가 맡는다.
# 모든 테이블은 반드시 하나의 primary key 를 가져야함

CREATE TABLE `shop_db`.`member1` (
  `member_id` CHAR(8) NOT NULL,
  `member_name` CHAR(5) NOT NULL,
  `member_addr` CHAR(29) NULL,
  PRIMARY KEY (`member_id`));

SELECT * FROM shop_db.member1;
= shop_db 데이터베이스 안에 member1 테이블로부터 모든 컬럼 정보를 보여달라. 라는 뜻이다.


SELECT 컬럼이름 FROM 스키마.테이블이름;
= 해당 테이블의 해당 컬럼만을 보여준다.

===============
SQL 주의사항
 쿼리문 안에 마우스 드래그된 부분이 있다면 드래그된 코드만 부분적으로 실행된다.
===============

쿼리문에서 schema 선택 방법

1. schema 를 더블클릭해서 볼드 글씨체 나오면 해당 schema가 선택되었음
	SELECT * FROM member1; 이렇게만 해도 문제없음

2. use 스키마이름;  이 문구로 스키마를 미리 선택할 수 있다.

3. SELECT * FROM shop_db.member1; 스키마를 직접 입력         


===================================

fk : 다른 테이블의 인덱스 값을 받아오는 데이터를 매칭시키는 역할
	foreign key 즉 왜래키 라고도 한다.
	왜래키는 한 테이블에 여러개 있어도 된다.
	데이터가 null 값이어도 된다.

======================================
특정 데이터만 , 혹은 특정 망가진 데이터만 선택하여 불러오기 가능
====

SQL은 오래된 소프트웨어이기에 다국어 처리가 어렵다. 한글 깨질 수 있다. 현직에서는 한글데이터를 잘 안넣는다.
========================

데이터를 선택하여 저장할 때 
USE market_db  스키마를  선택
select 컬럼1, 컬럼2, 컬럼3 from 테이블 이름 -- 데이터 열람 방법
=================================

데이터를 * 로 부르면 다 좋은데 데이터가 클때는 느려지고 불리해진다.

원하는 조건만 보고싶다. 아까처럼 열 데이터는 그대로인채로 원하는 조건만 뽑으려면?

SELECT * FROM 테이블이름 where 조건열=원하는데이터;


-날짜-
SELECT * FROM 테이블이름 where date(열 이름) = 원하는 기준;

 -EX)-
SELECT * FROM member where date(debut_date) < '2015-10-19';

=================
원하는 기준이 2개일 경우

 -EX)-
SELECT * FROM member where 160 < height and 164>height;

-> and, or 을 사용해서 조건을 두번 사용한다.

SELECT * FROM member where height between 162 and 164;
 -> between A and B 를 사용할 경우 초과 미만이 아닌 이상 이하로 적용됨


=========================================

SELECT mem_name, addr FROM member
where addr = '경기' or addr='전남' or addr='경남' ;
SELECT mem_name, addr FROM member
where addr in ('경기', '전남', '경남') ;

# 같은 결과 ^^
SELECT * FROM member where 160 <= height and height <= 165;
# 이친구는 이상 이하 값으로 경계값이 포함됨
SELECT * FROM member where height between 160 and 165;

SELECT mem_name, mem_number FROM member
 where mem_number = 4 ;

=========================================

like 사용법

select * from member where mem_name like'오%' or mem_name like '에%';

-ex)-
where 열이름 like'기준%' or 열이름 like'기준%';


========================================

서브쿼리

select height from member where mem_name = '에이핑크';
select mem_name, height from member where height > 164;
위의 작업을 한번에 하려면 아래 처럼 하면 된다.

select mem_name, height from member where height > (select height from member where mem_name = '에이핑크');

===========================================

EX)
비즈니스에서 성과별, 실적별 나열은 order by, (순서를 매긴다.)
EX)
비즈니스 팀 별 총 성과급 지급액은 group by (그룹화 한다.)

EX) 
데뷔일 순으로 나열하기 - order by
select mem_id, mem_name, debut_date from member order by debut_date desc;

-desc = 내림차순-	
-asc = 오름차순-

# order by 구문은 where 구문 뒤에 나와야함
order by 열 이름;

select height, mem_id, mem_name, debut_date from member where height >= 164 order by debut_date desc;
-> 이러면 기준을 추가하여 데이터를 나열할 수 있다.


EX)
2017년에 데뷔한 그룹 찾아서 한번에 보기 - group by

=============================================


select * from member limit 3;

limit n; 을 붙여서 n 줄만 출력할 수 있다.

===========================================

중복값을 빼고 싶을때

select distinct (열 이름) from 테이블이름;

==============================================
스키마명 market_db
테이블명 buy

# SELECT mem_id, sum(amount) FROM market_db.buy group by mem_id;
해당 열(mem_id, sum(amount)) 을 by mem_id 를 기준으로 묶어서 출력

# select * from buy;
buy 테이블 전체 출력

# SELECT mem_id, sum(price*amount) FROM market_db.buy group by mem_id;

SELECT mem_id, avg(price*amount) FROM market_db.buy group by mem_id;
mem_id, avg(price*amount) 열을 출력하고 

===============================================

SELECT count(*) FROM market_db.buy;

count(*) 사용시 데이터의 줄 갯수 출력

count(열 이름) 이러면 특정 컬럼에서 데이터가 온전한거만 개수를 센다(null을 제외한 나머지 개수)
그래서 count(*) 랑 결과가 달라질 수 있다.
======================================
++++++++++++++++++++++++++++++++++++++
======================================
2024 0426

SQL 의 특징

1. 여러계정이 동시에 활동 가능
 그래서 sql 파일을 더블클릭하면 별도의로그인 없이 열린다.

2. 한계정에서 여러개의 db  생성 가능
market_db, shop_db 이렇게 다수의 데이터베이스 구축 가능

3. 관계형 데이터베이스: 여러개의 테이블이 지정된 관계를 가지고 데이터를 엮을 수 있다.
->   직원테이블, 고객테이블, 구매기록테이블

 "관계형 데이터베이스는 설계가 중요하다" 
  - 무슨말이냐면, 적당한 데이터 배치와 테이블 개수 설정으로 빈 데이터 적재를 최소화한다.

"관계형 데이터베이스는 설계가 중요하다" - 무슨말이냐?
적당한 데이터 배치와 테이블 개수 설정으로 빈 데이터 적재를 최소화한다.
테이블간의 관계를 primary key & foreign key 로 연결할 데이터를 지정한다.
primary key: 테이블 안에 하나만 지정 가능, 중복안됨, 비어있어도 안됨

예시) 고객아이디, 회사 사번, 민증번호
foreign key : primary 가 지정한 데이터에 대한 매칭 데이터
한 테이블에 여러개가 있을수도 있고 테이블간 교류가 없다면 foreign key는 없어도 된다. 빈 데이터도 허용

========================================


CREATE DATABASE TEST;
TEST 라는 데이터베이스 생성됨

DROP DATABASE IF EXISTS TEST;
TEST 라는 스키마가 존재한다면 드롭해라 

----------------------

특정 스키마의 테이블을 부르면 스키마 지정을 해야한다.
어느 스키마에 소속된 테이블인지 모르기 때문이다.

CREATE TABLE testtable; 라고만 하면 오류 발생

스키마 지정방법 3개.

1. 스키마를 더블클릭해서 볼트표시 확인 - 이 스키마 사용중

2. use 스키마 이름 use market_db - 쿼리문으로 사용할 스키마 지정

3. 일일히 스키마 달아주기 CREATE TABLE 스키마.testtable;

=========================================

primary key는 원칙적으로 중복되면 데이터 식별이 어려우므로
중복데이터가 없어야 하는데 같은 key값의 분 단위 데이터라고 가정해보자

=========================================

AUTO_INCREMENT 는 데이터가 비워져있지 않도록 씩 자동으로 값을 증가시키며 데이터를 채운다. 
- primary key 종특 다른데이터는 비어있는게 정답인 경우가 대다수이므로 함부로 써서도 안된다.

==========================================

select 보고싶은_ 컬럼 이름 from 테이블이름 where 조건

------------------------------------------------------------------
ex>		schema = market_db,  table = member, buy

table member
APN	에이핑크	6	경기	031	77777777	164	2011-02-10
BLK	블랙핑크	4	경남	055	22222222	163	2016-08-08
GRL	소녀시대	8	서울	02	44444444	168	2007-08-02
ITZ	잇지	5	경남				167	2019-02-12
MMU	마마무	4	전남	061	99999999	165	2014-06-19
OMY	오마이걸	7	서울				160	2015-04-21
RED	레드벨벳	4	경북	054	55555555	161	2014-08-01
SPC	우주소녀	13	서울	02	88888888	162	2016-02-25
TWC	트와이스	9	서울	02	11111111	167	2015-10-19
WMN	여자친구	6	경기	031	33333333	166	2015-01-15
							

table buy
1	BLK	지갑		30	2
2	BLK	맥북프로	디지털	1000	1
3	APN	아이폰	디지털	200	1
4	MMU	아이폰	디지털	200	5
5	BLK	청바지	패션	50	3
6	MMU	에어팟	디지털	80	10
7	GRL	혼공SQL	서적	15	5
8	APN	혼공SQL	서적	15	2
9	APN	청바지	패션	50	1
10	MMU	지갑		30	1
11	APN	혼공SQL	서적	15	1
12	MMU	지갑		30	4
					

select * from member; -  멤버테이블 안의 모든 정보 출력

그런데, 멤버 테이블의 데이터가 많아서 일부만 출력하고 싶을 때

select * from member limit 5; - 이러면 5번째 줄 까지만 출력됨


멤버 수가 4명인 그룹만 출력하려면?
select mem_name, mem_number from member where mem_number = 4;

멤버 수가 3명 이상 5명 이하 그룹만 출력하려면?
select mem_name, mem_number from member where mem_number >=3 and mem_number <=5;

데뷔가 2015년 이전의 선배가수만 모셔옴
SELECT mem_name from member where date(debut_date) < '2015-01-01';

비교 연산자 사용하여 2가지 기준을 둘 때 and 를 사용하여 아래처럼 코드를 적는다
select * from member where height > 160 and height < 165;
select * from member where height < 165 and mem_number < 5 and height > 161;

 틀림 -> select * from member where height > 160 < 165;   <- 틀림

에이핑크의 키 데이터 보기
select mem_name, height from member where mem_name = '에이핑크';

에이핑크보다 키가 큰 걸그룹 데이터를 알고싶다면?
select mem_name, height from member where height > (select height from member where mem_name='에이핑크');

--------------------------------------------------------------------------
in 구문 활용법
select * from member where addr = '경기 or addr = '전남' or addr = '경남';
-->
select * from member where addr in('경기', '전남', '경남');

'오' 로 시작하는 걸그룹 이름을 알고싶다면 (% 는 '오'의 앞 뒤 전부 올 수 있다. '오'로 시작하는 단어라면 '오%')
select * from member where mem_name like '오%';

select * from member where mem_name like '오%' or mem_name like '에%';
이 경우 mem_name이 오마이걸, 에이핑크인 데이터 출력
---------------------------------------------------------------------------

++++++++++
order by - 정렬	     asc = 오름차순, desc = 내림차순	ex> order by 콜럼이름 asc
group by - 그룹화      ####group by를 사용할때 데이터를 집계하고 싶다면 where 대신 having(group by 뒤에 위치함.) 을 사용한다.####
++++++++++

예를 들어, 분단위로 지속적인 측정으로 데이터 4800만건, 시간단위로 60분 평균내서 측정하면 4800만을 80만건으로 줄일 수 있다.
일단위로 데이터 평균을 group by 한다면 약 3.3333만건
group by 중요함.
..............................................................
order by debut_date 이게 데뷔일 기준으로 정렬해달란 의미 

그룹들을 일찍 데뷔한 순서로 나열하려면 
select mem_id, mem_name, debut_date from member order by debut_date desc;

그룹들을 데뷔일 기준 내림차순으로 키가 164 이상의 그룹들만 출력하자
select mem_name, height from member c  where height > 164 order by debut_date desc;

* 여기서 order by 는 where 구문보다 뒤에 위치해야한다.
................................................................

데이터의 중복값을 빼고싶다면 distinct 를 활용한다.
select distinct addr from member;

* 실제 고객 구매데이터에서 고객 명수만 확인하고 싶을 때 사용한다.
------------------------------------------------------------------------------------------



mem_id 를 기준으로 구매금액의 합계 조사
select mem_id, sum(amount) from market_db.buy group by mem_id;

mem_id 를 기준으로 구매금액중 제일 비싼 금액 조사
select mem_id, max(amount) from market_db.buy group by mem_id;

mem_id 를 기준으로 구매 금액중 제인 싼 금액 조사
select mem_id, min(amount) from market_db.buy group by mem_id;

mem_id 를 기준으로 구매 평균 금액 조사
select mem_id, avg(amount) from market_db.buy group by mem_id;

mem_id 를 기준으로 구매 횟수 조사
select mem_id, count(amount) from market_db.buy group by mem_id;

- group by 된 키를 기준으로 묶어서 ()괄호 안의 키를 계산한다.(괄호 앞에 들어갈 sum max min avg count)-


평균 지출이 낮은 그룹부터 높은그룹까지 오름차순으로 나열
select mem_id, avg(price*amount) from market_db.buy group by mem_id order by avg(price*amount)asc;


----------------------------------------------------------------------
쿼리문을 작성하면서 콜럼명을 지정할 수 있다. 이것을 alias(별명) 이라고 한다.
주의할 점은 column 이름과 별명 사이에 콤마를 붙이지 않는것이다.

select mem_id "회원 아이디", sum(price*amount) "총 구매금액" from market_db.buy group by mem_id;
---------------------------------------------------------------------

예제)
회원 아이디 별 총 구매금액 뽑을 때 1000이상 구매한 사람만 뽑아주시오.(VIP 선별)

SELECT mem_id, sum(price*amount) 
from market_db.buy 
group by mem_id 
having sum(price*amount) >= 1000;
``````````````````````````````````````````````````````````````````````````````
여기서 구매금액 내림차순으로 나열하려면

SELECT mem_id, sum(price*amount) 
from market_db.buy 
group by mem_id 
having sum(price*amount) >= 1000 
order by sum(price*amount) desc;
++
특징에 대해서 짚고 넘어가자면, group by등으로 집계된 결과는
where구문을 쓸 수 없습니다. where말고 같은 기능의 having을 쓰셔야 합니다. 그리고 where가 아닌 having이므로 group by 뒤에 와야 합니다
order by는 맨 나중에 위치하게 되었습니다.
++

----------------------------------------------------------------------------

데이터 입력 및 변경

세미콜론 전에는 얼마든지 줄을 바꾸어도 한문장이다.



현재 아이디 몇번까지 만들어져서 들어갔는지 체크한다.
select last_insert_id();

drop table if exists hongong1;
만약 테이블이 존재한다면 삭제

-----------------------------------------------------------------------------------
다른 스키마에서 테이블을 복사하여 가져온다.

create table city_popul (city_name char(35), population int);
-- # 기존에 존재하는 테이블로 부터 원하는 정보를 전부 입력하려 한다면?
# 다른 데이터베이스의 테이블 정보도 무리없이 가져올 수 잇습니다
insert into city_popul 
select toy_name, age 
from market_db.hongong1;


데이터의 수정은 동시에 진행 가능하다.

# 원하는 정보만 담은 테이블을 새로 만든다.
create table city_population (city_name char(35), population int);
insert into city_population select name, population from city;


특정 데이터를 수정하기
update city_population set city_name = '뉴욕', population = 0 where city_name = 'new york';

city_population 테이블의 city_name 콜럼의 'new york' 를 city_name = '뉴욕', population = 0 로 수정


update city_population set population = population/10000;
도시의 인구수를 만명단위로 표시하기위해 10000으로 나누는 계산을 진행한다.


delete from city_population where city_name like 'new%';
delete 구문으로 데이터를 삭제할 때는 콜럼 정보를 입력하진 않는다.
그 이유는 행 전체를 날릴것이기 때문에 특정 조건을 만족하는 열이 아니면 굳이 언급할 필요가 없기 때문이다.
비슷한 방식으로 데이터에 빈 값이 있는 행을 날릴 필요가 있습니다.
예를 들어, 구매금액이 빠진데이터, 사용할 수진이 아닌 오류가 난 데이터를 날릴때는
delete from 테이블명 where 열_이름 is null; 라고 하면 된다.
null 값이 있다해서 모든 null 값이 있는 행을 날리면 안된다. null 값이 정상인 경우도 있다.

데이터를 삭제할 때 3가지 방법이 있습니다. 

delete from big_table1; - 
빈 테이블 양식은 남긴다.

drop table big_table2; - 무지성 삭제모드. 제일 빠르다.
drop은 테이블 자체가 전부 날아갑니다.

truncate table big_table3; - where 구문이 없음. 즉, 조건없이 삭제함
빈 테이블 양식은 남긴다.
* 편의성과 성능은 반비례


# 데이터 삭제방식 3가지를 테스트 하기 위해 테이블 3개를 만들어보려 한다.
use world;
create table big_table1 (select * from world.city, sakila.country);
create table big_table2 (select * from world.city, sakila.country);
create table big_table3 (select * from world.city, sakila.country);
# world 스키마에 big_table1 테이블이 생성되었다.

========================================
다른 스키마에서 테이블 가져오기
create table fender (manufactured int, shape char(100))
select manufactured, shape from market_db.fender;
=============================================