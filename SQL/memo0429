데이터 설계 --> 조인
데이터 추가, 수정, 사제 --> 중복입력이 가능
클릭 한번에 데이터가 중복이 들어오기 쉽다.

# 데이터의 수정은 동시에 진행 가능합니다.
# city_name 컬럼의 new york이란 데이터를 한글 뉴욕으로 고치고
# 인구수도 0으로 데이터의 변경이 가능하다
update city_popul set city_name = '뉴욕',
population = 0 where city_name = 'new york';
update 콜럼명 set 데이터이름 = '변경 값', 데이터이름 ='변경 값' set where 콜럼명 ='원래 값'


SQL 쿼리문은 누적되어 실행된다.

마우스 드래그를 활용해 일부만 실행하던지, 코멘트 처리로 필요한것만 실행하던지

하지만 보통은 데이터 생성 쿼리문은 별도의 파일에 작업한다.
============================================================

테이블간의 결합을 시키는 JOIN 문 배울 때

PRIMARY KEY & FOREIGN KEY 와의 관계 유형에 대해 자세히 다룰것이다.

1:N 관계(1 : 다수)      N:N 관계 ( 다수 : 다수 )

ex> IOT 장비를 채워서 개의 분당 활동량 측정 N:N 관계
    GROUP BY 로 데이터를 1일 데이터 등으로 변환하여 1:N 관계로 실무에서 처리하는 경우가 있다.


SQL 의 역할

    데이터에 대한 관계 설계
    테이블 구성
    데이터 속성에 따른 데이터 가공, 처리, 1:N 등의 관계 변환
    = 원하는 목적에 따라 데이터를 연결해야 한다.
================================================================

테이블이 복잡하면 한번에 정보를 가져올 수 없다. (서브쿼리)
ex
에이핑크보다 키 큰 사람들 추려내기 (에이핑크의 키 모르는 상태입니다.)
1. SELECT height from member where mem_name="에이핑크"; = 164
2. 164보다 키가 큰 사람들 추려내기
   select mem_name from member where height > 164;

이렇게 추려낼 수 있지만 일을 한번에 하기 위해서 서브쿼리를 사용
실무에서는 테이블간 연결이 안되있는 사례가 있다. 조인문 등으로 일할수 없는 경우
서브쿼리로 필요한 결과를 뽑아서 그 결과를 조건문에 걸어서 처리한다.
ex>
    select mem_id, height from member where height > ( select height from member where mem_name='에이핑크');
================================================================

데이터의 정렬 = order BY

데뷔일 기준을 내림차순으로 정리하느 경우 (desc) 내림차순 안쓰면 오름차순이 기본설정
order by는 where 뒤에 와야한다. 

select mem_id, mem_name, debut_date from member where height > 164 order by debut_date desc;
====================================================================================

데이터 집계 = group by

개별 구매 데이터를 목적에 맞게 가공하고 싶을 때 사용

select mem_id, sum(amount) from market_db.buy group by mem_id;
멤버 id 별로 구매액 총합 집계

select mem_id, max(amount) from market_db.buy group by mem_id;
멤버 id 별로 최대 구매액 집계

select mem_id, min(amount) from market_db.buy group by mem_id;
멤버 id 별로 최소 구매액 집계

select mem_id, avg(amount) from market_db.buy group by mem_id;
멤버 id 별로 전체 구매의 평균액수 집계

select mem_id, count(amount) from market_db.buy group by mem_id;
멤버 id 별로 전체 구매 횟수 집계


집계 데이터는 계산해서 집계가 가능하다 + 내가 원하는 콜럼 이름으로 설정 가능하다.

select mem_id "회원 아이디", sum(price * amount) "총 구매금액" from market_db.buy group by mem_id;

group by 에서 집계할때는 where 대신 having 이다. having은 group by 뒤에 위치한다.

EX> sum(price * amount) > 1000 이상인 그룹을 집계하시오

select mem_id, sum(price * amount) from buy group by mem_id havingsum(price * amount) > 1000;

================================================================================================

# primary key 안의 auto increment 기능 설명
use market_db;
drop table if exists hongong1;
#toy_id, toy_name, age 컬럼이 있는 hongong1 테이블 생성
create table hongong1 (toy_id int auto_increment primary key, toy_name char(4), age int);
# toy_id 를 프라이머리 키로 설정
insert into hongong1 values (null, 'dino', 5);
insert into hongong1 values (null, 'dino', 5);

#toy_id에 auto_increment 를 설정하고 null 값을 넣어 insert into 하였기에 순차적으로(1, 2, 3 ~) 번호가 매겨지며 입력된다.
auto_increment 기능의 시작점과 숫자 증가량을 설정할 수 있다.

EX> 특정 일 이후 중간 데이터는 10000 으로 시작하고 33씩 증가시켜서 구분을 하고자 한다.

alter table hongong1 auto_increment = 10000;
-> 이 문장이 위치한 후로 데이터가 입력된다면 auto_increment 값이 10000에서 시작한다.

set @@auto_increment_increment = 33;
-> auto_increment 가 33씩 증가한다.

================================================================================================

update, delete 구문은  안전모드 옵션이 켜져 있으면 안됩니다. 안전모드 해제

===============================================================================================

#데이터 추가 후 new 로 시작하는 도시이름을 모두 열람하고 싶을 때 %와 같이 하나 이상이 아무  글자나 가리킬 수 있는 문자를 와일드카드 문자라고 한다.
#와일드카드 사용시, 정확히 매치한다는 의미의 = 를 쓰며 안되고 like를 사용한다.

# select * from world.city_popul where city_name like 'new%';
# new 로 시작하는 도시를 모두 열람할 수 있다.

#이제 열람한 데이터를 삭제해보자.
#데이터 삭제는 행 전체가 삭제되므로 딱히 삭제할 컬럼 지정은 안해도 된다.
delete from city_popul where city_name like 'new%';

# 위 예제를 활용하여 빈값이 존재하는 데이터행을 날릴 수 있습니다.
# delete from 테이블 명 whrer 컬럼 is null;
# 빈 값이 존재하는 테이터 행을 삭제할 때 주의할 점은 빈값의 데이터가 반드시 오류 데이터는 아니라는것을 명심하자.

================================================================================================


use world; 
drop table if exists big_table1;
drop table if exists big_table2;
drop table if exists big_table3;
create table big_table1 (select * from world.city, sakila.country);
create table big_table2 (select * from world.city, sakila.country);
create table big_table3 (select * from world.city, sakila.country);

# 위 쿼리문 입력하면 테이블 당 데이터가 44만줄 저도 나온다. 왜 그런걸까?

join문은 왜 배우는가?
-> 테이블 안의 데이터끼리 관계를 설정하지 않으면 중복을 허용하는 조합으로 데이터 생성이 된다. 
즉, 4079줄의 world.city 데이터의 각 행이 109줄의 sakila.country 데이터를 전부 가지면서
109줄의 country 데이터가 4079번 반복되는 효과를 가지기 때문이다.
이것이 N:N (다수 : 다수) 관계의 예시이다

빅데이터의 삭제모드를 위한 아무 빅데이터셋이 필요해서 위 예시를 활용했지만
데이터 설계의 측면에서 좋지 않은 예시이다.

#데이터 삭제방식 3가지 delete, dropk, truncate 적용

delete from big_table1; - 
빈 테이블 양식은 남긴다.

drop table big_table2; - 무지성 삭제모드. 제일 빠르다.
drop은 테이블 자체가 전부 날아갑니다.

truncate table big_table3; - where 구문이 없음. 즉, 조건계산 없이 삭제함 그렇기에 가장 빠르다.
빈 테이블 양식은 남긴다.

* 편의성과 성능은 반비례
=============================================================================================

조인은 inner join과 outer join 크게 두가지를 많이 쓴다.

1. inner join (내부조인)
내부 조인은 primary key가 있는 정보에 한해서만 정보표시
그리고 데이터는 1:n 관계로 이루어져야한다.
사번과 구매기록, 게임아이디와 게임 접속기록 등의 데이터 관계를 생각하자.

inner join (내부조인)은 결국 primary key 와 다른 테이블간의 "관계"를 나타낸다.
일대 다 관계 즉, 1:n 관계는 pk-fk 관계라고도 한다.

use market_db;
select * from buy inner join member on buy.mem_id = member.mem_id where buy.mem_id = 'apn';
# 두 테이블에 모두 존재하는 mem_id 컬럼을 기준으로 member 테이블의 데이터를 출력한다.

inner join에서 * 를 쓰면 양쪽 테이블의 모든 컬럼값을 다 가져온다.
pk, fk 는 의미적으로 동일한 데이터입니다. 그래서 중복결과를 가져왔습니다.
그래서 join 문 할대는 일반적으로 * 말고 내가 가져오고싶은 컬럼은 명시한다.

N:N 관계는 학생과 동아리 관계이다. 
한 학생은 여러 동아리에 가입할 수 있고 동아리는 여러 학생들을 받을 수 있다.

이커머스의 예시로, 고객과 사용 구매플랫폼의 관계 역시 N:N 즉 다수 : 다수 관계이다.
한명의 고객은 알리 쿠팡 테무 아마존 가입가능 각 업체들은 여러 고객을 받을 수 있음

use market_db;
# my sql은 직접적인 outer join 명령은 없습니다.
# 그래서 left outer join과 right outer join의 합집합으로
# 해당 데이터를 만듭니다.
select * from buy left outer join member on buy.mem_id = member.mem_id union select * from buy right outer join member on buy.mem_id = member.mem_id;



# join 문 사용시 주의할 점
# 양쪽 테이블에 같은 이름으로 모두 있는 정보는 어느 테이블 소속 정보인지 모른다.
# 따라서 어느 테이블의 컬럼인지 명시해야한다.

use market_db;
select buy.mem_id, prod_name, addr, price, amount from buy inner join member on buy.mem_id = member.mem_id;

# join 문을 쓸 때, 중복되는 컬럼 이름이 아니면 소속 테이블을 스지 않아도 실행은 됩니다. 
#근데 다른 사용자는 알아보기 힘들 수 있기 때문에 테이블 정보를 써두는것이 좋다.


select B.mem_id, B.prod_name, M.addr, B.price, B.amount
from buy B
inner join member M
on B.mem_id = M.mem_id;
# 테이블과 콜럼에 별명을 지을 경우 쿼리에 별명을 사용 할 때 전부 일관되게 별명으로 작성해야함


inner join 은 양쪽 PK, FK에 모두 정보가 있는 결과만 준다. 즉 구매한적 없거나 회원을 탈퇴하여 우리 DB에
아이디 정보가


만약 고객에게 감사장을 돌리고 싶어서 구매기록의 고객아이디 리스트를 뽑고싶다면?

select distinct M.mem_id, m.mem_name, m.addr from buy b inner join member m on b.mem_id = m.mem_id order by m.mem_id;



OUTER JOIN (외부 조인)

외부 조인은 크게 left outer join,  right outher join 두가지로 나뉘는데, 의미는 한쪽의 PK 혹은 매칭되는 FK 에 있는 정보를 모두 뽑는다는 이야기이다.
우리 예시에는 탈퇴 걸그룹의 구매데이터는 없지만 있다고 가정해보자.





#ex) 구매기록이 없는 고객에게만 쿠폰을 뿌리기 위해 데이터 출력
	where B.prod.name is null; 붙이면 된다.
    
#ex) 구매기록이 있는 사람만 이벤트 초대하고싶다. 구매기록 잇는 사람만 추리기 위해?al
	where b.prod, nane is not null; 붙이면 된다


select M.mem_id, B.prod_name, M.addr, B.price, B.amount
from member M
left outer join buy B
on B.mem_id = M.mem_id;


======================================================================================================
SELF JOIN
자체 조인

회사의 인사조직에서 주로 이용한다.
예시 데이터의  EMP : 담당자,  MANAGER : 그 사람의 상관,  Phone : 전화번호

질문> 경리부장 상관의 전화번호를 알고싶다면?
데이터베이스는 당장 그 사람의 전번만을 알고있다. 경리부장 데이터로 그 사람의 상관의 데이터인 관리이사를 알아내서
그 관리이사의 전화번호 데이터에 접근해야함

1. 경리부장의 데이터에 접근하여 관리이사라는 상관데이터를 입수한 후
    경리부장 관리이사 2222-1

2. 관리이사 상가ㅗㄴ데이터와 직원 관리이사 데이터를 조인시켜서 아래 정보에 접근하여 전화번호를 2222를 알아낸다.
    관리이사 대표


SELECT A.EMP '직원', b.emp '직속상사', b.phone '직송상관 전번'
from EMP_table a
inner join emp_table b
on a.manager = b.emp
where a.emp='경리부장';

# inner join 문으로 담당자와 담당자 보스데이터에 대하여 테이블을 묶습니다.
# 그 후 담당자 데이터를 where 조건을 걸어서
# 묶여있는 그 담당자의 상사 데이터와 그 사람의 전화번호를 불러옵니다.

==================================================================================================

where a.emp = '경리부장';

inner join, left outer join, right outer join, 자체조인(self join)

PK: PRIMARY KEY 
NN: NOT NULL (비어있으면 안됨)
UQ: UNIQUE (유일한 값이어야한다.)
UN: UNSIGNED (마이너스 값 없음 - ex 키, 몸무게)
AI: AUTO INCREMENT ( 자동으로 숫자 추가해서 값 달아주는 기능)
B : BINARY DATA (이진데이터 0, 1)
ZF : ZERO FILL (0으로 채우기)
G: GENERATED ( 수식등으로 인해서 자동으로 생성되는 컬럼)
==================================================================================================

예제>>

EMP2 스키마에 EMP, DEPT 테이블이 있습니다.
EMP 는 근로자 정보 테이블이고
DEPT는 부서관련 정보 테이블입니다.

1. 근로자 정보테이블에서 사번, 이름, 월급을 출력하시오
=
    use EMP2;
    select empno '사번', ename '직원명', SAL '월급' from emp;


2. 회사가 대박나서 월급의 1.5배 성과급을 준다고 한다.
 근로자 정보테이블(EMP) 에서 사번, 이름, 성과급 정보를 출력하시오
 성과급 정보는 "성과급" 이라고 컬럼 이름을 바꿔주세요
=
    use EMP2;
    select empno '사번', ename '사원명', (sal * 1.5) '성과급' from EMP;


3. EMP 테이블에서 직업 출력 시 중복값을 제거하고 출력했으면 좋겠습니다.
=
    use EMP2;
    select distinct job from EMP;


4. 3번 결과를 오름차순, 내림차순으로 한번씩 정렬

오름
    use EMP2;
    select distinct job from EMP order by job asc;

내림
    use EMP2;
    select distinct job from EMP order by job desc;


5. 2번 문제의 성과급을 오름차순 정렬하시오
    콜럼에 별칭이 있다면 일관성을 맞추자.

    use EMP2;
    select empno '사번', ename '사원명', sal * 1.5 '성과급' from EMP order by 성과급 asc;

6. EMP 테이블 정보를 이름, 부서코드(DEPTNO), 월급(SAL) 정보를 열람하시오, 
    단, 부서번호 오름차순, 후에 월급 정보를 내림차순

    use EMP2;
    select empno '사번', DEPTNO '부서번호', SAL '월급' from EMP order by 부서번호 asc, 월급 desc;

7. 월급이 3000이상인 직원들의 이름, 직업, 월급을 보여주시오

    select empno, job, sal from emp where sal >= 3000;


8.  이름이 SCOTT인 사원의(emp 테이블 자료)
    이름, 월급, 직업, 입사일, 부서 번호를 출력하라

    select ename, sal, job, hiredate, deptno from emp where ename = 'SCOTT';


* 데이터를 집계할 때 일부데이터가 null 일때
   직원별로 월급 + 커미션을 합산한 총 금액을 출력하고 싶다면.

select ename, sal + comm, job, hiredate, deptno from emp;

이 결과 sal + comm 콜럼의 데이터에 null 값이 나타났다.

이 때 comm 콜럼의 null 값 데이터로 인해 원래 있던 sal 의 데이터가 사라지고 합산에서 null 로 표기되기 때문에

select ename, sal + ifnull(comm,0), job, hiredate, deptno from emp;
이렇게 하여 출력할 수 있다.

 - 오라클에서는 nvl함수, mysql에서는 ifnull 함수로 문제 해결 가능하다

 9. 연봉이 20000 이상인 사원들의 이름와 연봉을 출력하라 단, 월급의 콜럼은 sal 이다.

    select ename, (sal *12) '연봉' from emp where (sal *12) >= 20000 ;

10. salesman 이 아닌 직원들의 사번, 이름, 직업을 출력하라

    select ename, empno, job from emp where job != 'salesman' ;


11. 월급이 1000에서 3000사이인 직원들의 이름과 월급을 출력하라

    select ename, sal from emp where sal >= 1000 and sal <= 3000 ;
 or between 1000 and 3000;
 초과, 미만의 경우는 
    select ename, sal from emp where sal > 1000 and sal < 3000 ;

12. 월급이 1000에서 3000사이가 아닌 직원들의 이름과 월급을 출력하라

    select ename, sal from emp where sal < 1000 or sal > 3000 ;


13. 이름이 S 로 시작하는 사원의 이름과 월급을 출력하라

    select ename, sal from emp where ename like 's%';


14. 이름이 t 로 끝나는 사원의 이름과 월급을 출력하라

    select ename, sal from emp where ename like '%t';


15. 이름에 a 를 포함하는 사원의 이름과 월급을 출력하라

    select ename, sal from emp where ename like '%a%';

16. 이름에 2번째에 a가 들어가는 사원의 이름 월급 출력
    
        select ename, sal from emp where ename like '_a%';


17. 이름에 3번째에 a가 들어가는 사원의 이름 월급 출력
    
        select ename, sal from emp where ename like '__a%';

18. 직업이 salesman, analystm manager 인 사원들의 이름 월급 직업 출력

    select ename, sal, job from emp where job = 'salesman' or job =  'analyst' or job = 'manager';

19. 직업이 salesman, analystm manager가 아닌 사원들의 이름 월급 직업 출력

    select ename, sal, job from emp where job != 'salesman' and job !=  'analyst' and job != 'manager';;


20. 사번 월급 부서 출력하되 부서별 데이터는 오름차순 정리, 같은 부서끼리의 월급은 내림차순, 월급이 2000 이상만.

    select empno, sal, deptno from emp where sal >= 2000 order by deptno asc, sal desc;


21. 사원 테이블에서 최대 월급을 출력하라

    select max(sal) from emp;


22. 세일즈맨 직군의 최대월급 출력하라

    select job max(sal) from emp;


23. 사원테이블에서 salesman 직군의 최대월급 출력

     select job, max(sal) from emp where job = 'salesman' group by job;

      select job, max(sal) from emp group by job having job = 'salesman';

* where 와 having 사용법 정리
 - where 는 그룹화 전에 조건 처리로
 - group by 에서 having 을 더 권장하는 이유는 sql 실행 순서 측면에서 그룹화 전에 조건이 처리되므로
 - 수리적인 작업에서 논리적인 충돌이 발생하기 때문이다.


24. 직업별 최소 월급 출력 (스키마 emp2  테이블 emp) 
 
    select job, sal from emp group by job order by min(sal) desc;


25. 직업과 직업별 토탈 월급 출력, 단 직업별 토탈 월급을 내림차순으로 나열

    SELECT JOB, sum(sal) from emp group by job order by sum(sal) desc;


26. 직업별 토탈 월급 출력, 단 4000 이상만 출력

    select job, sum(sal) from emp group by job having sum(sal) >= 4000;


27. 직업별 토탈 월급 출력, 단 4000 이상만 출력, 세일즈맨 제외한

    select job, sum(sal) from emp where job != 'salesman' group by job having sum(sal) >= 4000;

28. emp 테이블에서 null 값이 있는 데이터행의 개수 출력

    select count(ename) from emp where comm is null;
    - ename 의 개수르 세되 comm 이 null 이라는 조건을 걸어서 null 의 개수를  센다.

29. sqldb 에서 userid 가 jyp 인 사람을 모두 출력하시오 (구매기록 배송정보 포함)

use sqldb;
select * 
from buytbl 
inner join usertbl 
on buytbl.userid = usertbl.userid
where buytbl.userid = 'jyp'


30. 한번이라도 물건을 구매한 사람들을 모두 출력하시오

    select distinct u.userid, u.name, u.addr from usertbl u inner join buytbl b 
    on u.userid = b.userid order by u.userid;

31. 한번도 물건 구매하지 않은 사람 출력하시오

    select userid, name, addr from usertbl 
    where userid not in (select distinct u.userid, u.name, u.addr from usertbl u inner join buytbl b 
    on u.userid = b.userid order by u.userid);

* 단수가 아닌 복수데이터 이기에 not in 사용  단일에서만 != 사용
