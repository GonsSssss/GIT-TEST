자격증에서도 그렇지만 실무에서
*****테이블 간의 결합을 시키는 JOIN문
거래처 별, 개인정보 별, 권한 별로 데이터가 분리되어 들올 수 밖에 없다
예) 쿠팡 - 수많은 판매자를 유치하고 데이터 받기
곰곰과 같은 자체 브랜드 입점업체가 많습니다
자체 브랜드 별 그들이 제출하는 상품, 쿠폰, 설명, q&a데이터 등
데이터 테이블은 기본이 수백테이블이 됩니다.


PRIMARY KEY & FOREIGN KEY와의 관계 유형을 파악하자
일반적으로 1:n 관계가 데이터 관계지정에 좋다
primary key값 하나에 (주민번호 한개)
foreign key값 데이터 여러개 (음주기록, 전과기록, 병역기록, 세금기록)
시간의 흐름에 따라 데이터가 생성되는 경우가 많으므로 실제로는 
n:n 관계도 많다 

데이터를 가공한다 --> 목적에 맞게 데이터 변환  (group by)
일별 카드 사용 내역을 합쳐서 
현대카드 3개월 명세서 표시 분기 별 소비액 보여준다
--> 집계한다고 합니다.
sum, avg, max, min, count  합산, 평균, 최대, 최소, 건수세기
고객 id별로 개별구매아이템 금액의 합계를 집계하고플때 사용
select mem_id, sum(amount) from market_db.buy group by mem_id;

집계 할 때 수식 계산 기능을 지원한다 + 내가 원하는 컬럼 이름으로 지정가능
select mem_id, sum(price * amount) '총 구매액' 
from market_db.buy 
group by mem_id;
***group by 기능으로 집계할 때는 조건을 나타내는 where 구문 사용이 불가합니다. 같은 기능으로 having이 있습니다
방금 예제에서 총 구매금액을 따질때 구매액 1000초과 고객만 뽑고 싶을 때는
select mem_id, sum(price * amount) '총 구매액' 
from market_db.buy 
group by mem_id 
having sum(price * amount) > 1000;

# primary key안의 auto increment 기능 설명
# auto increment 기능은 primary key에서 사용하는 기능인데 데이터 부재 시 자동으로 1씩 채워주는 기능이다. 다른컬럼에서는 쓰지못한다. 데이터가 빈것이 맞는경으도 많다. (0이랑 데이터가 빈 것은 아예 다른이야기다) 
use market_db;
drop table if exists hongong1;
# toy_id, toy_name, age 컬럼이 있는 hongong1 테이블을 만듭니다
create table hongong1 (toy_id int auto_increment primary key,
toy_name char(4), age int);
set @@auto_increment_increment=1;
insert into hongong1 values (null, '안녕', 25);
insert into hongong1 values (null, 'ㅎㅇ', 32);
insert into hongong1 values (null, '잘가', 42);

primary key 안의 데이터는 중복값 불가!!!! 빈값 불가!!!
그래서 시계열 데이터 집어넣을때는 미리 만들어진 데이터를 넣을 순 있어도 (특수한 조건) 원칙적으로 sql을 통한 primary key 데이터의 중복값은 허용되지 않는다.
# auto_increment 기능의 시작점과 숫자 단위는 설정가능하다
# 원래는 1에서 시작해서 1씩 증가해야 하는데
# 예) 특정일 이후 중간 데이터는 10000으로 시작하고 
# 33씩 증가시켜서 구분을 하고자 할때
# 거래처 별로 primary key 값을 다르게 설정
# 현대카드 관계자가 구매데이터 처리할 때 거래처 마다 고유의 primary key값을 설정하려는 경우
# 알리는 100만, 쿠팡은 50만, 지마켓은 1000만
# 예) hongong1 테이블의 auto_increment를 1만으로 시작하도록 하고 추가로 오는 데이터는 33씩 증가시킴
# 주의: 아래 쿼리문은 누적으로 실행되므로 별도의 쿼리파일에서 
'순차적으로'실행하세요 (데이터 만들고 나서 별도파일에서 실행)
alter table hongong1 auto_increment=10000;
set @@auto_increment_increment=33;

데이터의 삭제를 보겠습니다
어제 삭제 예제를 다시 해보려고 합니다. 아래 쿼리문을 실행하여 
테이블을 생성하고 테이블 내 데이터를 추가하여 주시기 바랍니다
삭제 예시를 보이기 위한 테이블 및 데이터 생성 쿼리문 입니다
drop table if exists city_popul;
create table city_popul (city_name char(35), population int);
insert into city_popul select name , population from city
# new라고 시작하는 도시 이름을 끄집어 내기
# %와 같은 와일드 카드 문자 사용 시 = 사인말고 like로 써야함
SELECT * FROM world.city_popul where city_name like 'new%' ;

# 열람한 데이터를 삭제해 보겠습니다
# 삭제 구문은 열람과 매우 유사한데, 컬럼지정이 필요하지 않습니다
# 왜? 행 전체를 날릴거니까 ㅎ
delete from world.city_popul where city_name like 'new%';

# 특정 컬럼에서 빈값이 존재하는 데이터 행을 삭제할 수 있습니다
# 이렇게 데이터값이 있어야 할 자리에 데이터가 없는 데이터를 없애면서
# 온전한 데이터만을 남기는 것을 데이터 클리닝, 클렌징 이런식으로 부릅니다

market_db 에서 buy테이블 내 groupname컬럼의 빈데이터를 가진 불량데이터를 삭제하는 쿼리문 입니다. 이런식으로 빈 컬럼값을 가진 데이터를 없앨 수 있습니다
# delete FROM market_db.buy where group_name is null; 

데이터 삭제 3가지 방식: truncate, delete, drop 3가지 있습니다
drop: 테이블 구조까지 무지성 삭제 - 제일 빠르다
delete: 조건 따져가며 데이터만 삭제 - 제일 느리다
truncate: 조건 따지지말고 데이터만 삭제 - 두번째로 빠르다

데이터 삭제방식 3가지 delete, drop, truncate의 적용
-- # 빈테이블 양식은 남깁니다
-- delete from big_table1;
-- # drop은 테이블 자체가 전부 날아갑니다 - 무지성 삭제모드이고 무지성이니까 제일 빠르다
-- drop table big_table2;
-- # truncate는 빈 테이블 양식은 남깁니다 - where구문이 없음. 즉, 조건없이 삭제함
-- truncate table big_table3;

테이블 간의 결합을 시키는 JOIN문은 데이터간의 관계를 파악해야 가능하다
구매데이터 테이블의 구매 목록은 누가 산걸까?
이번 승진자 데이터 테이블에서 승진자는 누구인가?
추석 소고기 설문조사 = 살치살은 누가 시킨걸까?
일반적으로 1:n 관계가 데이터 관계지정에 좋다
primary key값 하나에 (주민번호 한개)
foreign key값 데이터 여러개 (음주기록, 전과기록, 병역기록, 세금기록)
그러면 n:n 관계는 무엇인가?
대학생과 동아리의 관계 - 대학생은 여러동아리 가입가능
한 동아리도 여러명의 대학생 유치가능

inner join 실습: 
market_db 안의 member & buy 테이블 정보에서 걸그룹 코드 데이터인
primary key & foreign key 모두 데이터가 있는 데이터만을 가져온다

누가 무엇을 구매했는지 확인하는 쿼리문을 작성해 보겠습니다
select * from buy
inner join member 
on buy.mem_id = member.mem_id;
한마디로 mem_id 컬럼의 grl데이터는 buy테이블에도 값이 있어야 하고
member테이블에도 값이 있어야 한다
* 쓰면 중복된 컬럼도 그렇고 이용하지 않는 정보까지 들오므로 join 구문 사용 시 원하는 컬럼을 지정하는게 좋다 (쿼리문이 느려진다)
단, 양쪽테이블이 동일한 이름을 쓰는 컬럼은 어디테이블인지 명시해야함
테이블을 명시하지 않으면 쿼리상으로 오류를 보여주지않고 결과만 안나온다
select buy.mem_id, prod_name, addr, price, amount from buy
inner join member 
on buy.mem_id = member.mem_id;

실무에선 테이블당 컬럼 개수가 수십 수백개 일 수 있다.
테이블의 컬럼개수가 많은것을 high-dimensional data라 한다 (고차원 데이터)
이러한 고차원 데이터는 계산 성능에 매우 좋지않다
왜???? 데이터를 메모리에 입력 후 작업 할 때 데이터가 메모리를 많이 차지하므로
성능 효율성 측면에서 성능저하의 원인이 된다
연산 코어 수 = 택배일꾼 숫자
메모리 = 도로
고차원데이터의 이동이 어렵기 때문에 중간 결과를 보내고 받는게 느리다
좁은 깔때기로 18리터 생수통물을 처리하는격으로 
고차원데이터는 연산성능에 불리하게 작용한다.
그래서 테이블 이름을 명시함으로 데이터의 dimension 즉 데이터차원의 수를 통제하고 원하는 값만을 불러와야 후속 데이터 연산성능이 저하되지 않는다.

어느 테이블 소속 컬럼인지 전부 달아주는 것이 협업에 도움이 된다.
select buy.mem_id, buy.prod_name, member.addr, buy.price, buy.amount from buy
inner join member 
on buy.mem_id = member.mem_id;

다만, 테이블 이름을 입력할 때 코드 가독성 이슈가 있으므로, 테이블에 별명을 달아줍니다. 주의할 점은 별명을 지었다면 모든 쿼리문에 별명을 일관되게 써야함
select B.mem_id, B.prod_name, M.addr, B.price, B.amount from buy B
inner join member M 
on B.mem_id = M.mem_id;

아래와 같이 컴퓨터는 데이터의 컬럼을 없다고만 말합니다
Unknown column 'buy.mem_id' in 'on clause'   0.000 sec

INNER JOIN은 양쪽 PK, FK에 모두 정보가 있는 결과만을 줍니다
즉, 구매한 적이 없거나 회원을 탈퇴하여 우리 DB에 아이디 정보가 없는 사람의 기록은 나오지 않습니다

탈퇴한 그룹이 물건 산 내역도 회계결산 차원에서 확인은 하고싶은 경우
그 때 쓰는 것이 OUTER JOIN (외부조인) 구문입니다
외부조인은 LEFT OUTER JOIN, RIGHT OUTER JOIN 두가지가 있습니다
멤버 테이블에 데이터는 없지만 구매 기록에 있는 친구들은 다 불러오고 싶다면???

select B.mem_id, B.prod_name, M.addr, B.price, B.amount 
from buy B
left outer join member M 
on B.mem_id = M.mem_id;

아까 buy 테이블에 임시로 지금은 해체되고 없어서 member테이블에 없는 룰라 데이터 입력을 시도하였습니다. 그런데 데이터가 입력되지 않았죠?
이게 foreign key값의 제약 사항입니다.
primary key에 대응하는 데이터가 없는 foreign key데이터는 입력이 불가합니다
primary key와 foreign key의 관계를 해치는 경우, 데이터도 함부로 못지워요 ^^

right outer join을 이용해서 member 테이블정보는 다 불러와야 한다면?
select B.mem_id, B.prod_name, M.addr, B.price, B.amount 
from buy B
right outer join member M 
on B.mem_id = M.mem_id;

만약에 왼쪽 오른쪽 모든 테이블에 존재하는 모든정보를 다 합치고 싶다면???
union구문으로 left outer join & right outer join두 정보를 합집합 처리 ^^
select B.mem_id, B.prod_name, M.addr, B.price, B.amount 
from buy B
left outer join member M 
on B.mem_id = M.mem_id
union
select B.mem_id, B.prod_name, M.addr, B.price, B.amount 
from buy B
right outer join member M 
on B.mem_id = M.mem_id;
join 구문에도 where절을 통한 조건문 설정이 가능합니다.
# 구매기록이 없는 사람도 같이 불러옴
# 구매기록 없는 사람 조회해서 쿠폰을 뿌린다던지 할때 정보조회 가능
select m.mem_id, B.prod_name, M.addr, B.price, B.amount 
from buy B
right outer join member M 
on B.mem_id = M.mem_id
where b.prod_name is null;

아까 inner join 테이블에서 구매금액 뽑을 때 총 금액을 집계해서 뽑으려고 한다면?
select buy.mem_id, buy.prod_name, member.addr, sum(buy.price* buy.amount) from buy
inner join member 
on buy.mem_id = member.mem_id
group by buy.mem_id, buy.prod_name, member.addr;

# 사원 테이블에서 사번 empno, 
# 이름 ename, 월급 sal을 출력하라
-- use emp2;
-- SELECT EMPNO, ENAME, SAL
-- FROM EMP;

# Q. 사원 테이블의 사원 번호와 이름, 월급을 출력하는데 
# 컬럼명을 한글로 '사원 번호'. '사원 이름'으로 출력하라. (alias)
-- use emp2;
-- SELECT EMPNO '사원 번호', ENAME '사원 이름', SAL
-- FROM EMP;

# 사장님이 월급의 1.5배를 보너스로 주셨습니다
# 사번과 보너스 데이터를 보여주세요 alias로 보너스라고 표시해주셔도 좋아요
-- use emp2;
-- SELECT EMPNO '사원 번호', ENAME '사원 이름', SAL *1.5 '보너스'
-- FROM EMP;

# 직원테이블에서 직업별로 중복을 제거하고 결과를 보여주세요 
-- select distinct job from emp;

# 사장님이 월급의 1.5배를 보너스로 주셨습니다
# 사번과 보너스 데이터를 보여주실때 보너스의 내림차순으로 보여주세요
-- use emp2;
-- SELECT EMPNO '사원 번호', ENAME '사원 이름', SAL *1.5 '보너스'
-- FROM EMP
-- order by 보너스 desc;

# 사번, 월급, 부서를 보여주시되, 부서별 데이터는 오름차순으로 정리 후
# 같은 부서에서 월급은 내림차순으로 보여주세요
-- SELECT ENAME, DEPTNO, SAL
-- FROM EMP
-- ORDER BY DEPTNO ASC, SAL DESC;

# emp2 스키마 안에 emp 테이블에서
# 월급이 3000이상인 직원들의 이름, 직업, 월급을 보여주세요
-- select ename, sal, job 
-- from emp 
-- where sal >= 3000;

# 이름이 SCOTT인 사원의 (emp테이블 안 자료)
# 이름, 월급, 직업, 입사일, 부서 번호를 출력하라
-- select ename, sal, job, hiredate, deptno
-- from emp
-- where ename='scott';

# 데이터를 집계할 때 일부데이터가 null일때
# 직원 별로 월급+커미션을 합산한 총 보수를 뽑고 싶을때
# 모든 빈 데이터가 틀린건 아냐 - 커미션 데이터가 없는 사람은
# 커미션을 받지 않는 조건으로 입사했다고 가정
# 비어있는 커미션 데이터 자체를 수정해선 안되
# 단, 커미션 데이터가 없는 사람은 커미션 제외한 월급이 총 보수라 가정
use emp2;
select ename, sal+ifnull(comm,0.000001), job, hiredate, deptno
from emp;
# 오라클에선 nvl함수, mysql에선 ifnull함수로 문제해결 가능
# 센스퀴즈: 저기서 null일으키지 않고 커미션 null알아내는법

# sal 컬럼은 월급데이터란걸 확인하였습니다
# 연봉이 20000 이상인 직원들의 이름과 연봉을 출력하라
-- select ename, sal * 12 from emp where sal * 12 >= 20000;

# 직업이 SALESMAN이 아닌 직원들의 
# 이름과 부서 번호, 직업을 출력하라
SELECT ENAME, DEPTNO, JOB
FROM EMP
WHERE JOB != 'SALESMAN';

# 월급이 1000에서 3000사이인 직원들의 이름과 월급을 출력하라
-- select ename, sal
-- from emp
-- where sal between 1000 and 3000;
# 월급이 1000초과 3000미만인 직원들의 이름과 월급을 출력하라
SELECT ENAME, SAL
FROm EMP
WHERE (SAL > 1000 AND SAL < 3000);

# Q. 월급이 1000에서 3000사이가 아닌 
# 사원들의 이름과 월급을 출력하라
SELECT ENAME, SAL
FROM EMP
WHERE (SAL < 1000 OR SAL > 3000);

# 이름의 첫 글자가 S로 시작하는 사원들의 이름과 월급을 출력하라
SELECT ENAME, SAL
FROM EMP
WHERE ENAME LIKE 'S%';
# 이름의 끝 글자가 T로 끝나는 사원들의 이름과 월급을 출력하라
SELECT ENAME, SAL
FROM EMP
WHERE ENAME LIKE '%T';
# 이름에 A를 포함하고 있는 사원들의 이름을 출력하라
SELECT ENAME, SAL
FROM EMP
WHERE ENAME LIKE '%a%';
# 이름의 두 번째 철자가 M인 사원의 이름과 월급을 출력하라;
SELECT ENAME, SAL
FROM EMP
WHERE ENAME LIKE '_m%';
# 이름의 세 번째 철자가 M인 사원의 이름과 월급을 출력하라;
SELECT ENAME, SAL
FROM EMP
WHERE ENAME LIKE '__m%';

# 직업이 SALESMAN, ANALYST, MANAGER인 사원들의 이름, 월급, 직업을 출력하라
SELECT ENAME, SAL, JOB
FROM EMP
WHERE (JOB = 'SALESMAN' OR JOB = 'ANALYST' OR JOB = 'MANAGER');

# 직업이 SALESMAN, ANALYST, MANAGER가 아닌 사원들의 이름, 월급, 직업을 출력하라
SELECT ENAME, SAL, JOB
FROM EMP
WHERE (JOB != 'SALESMAN' AND JOB != 'ANALYST' and JOB != 'MANAGER' );



